#include <winsock2.h>
#include <windows.h>
#include <iostream>
#include <random>
#include <time.h>
#include <vector>
#include <map>
#include <ws2tcpip.h>
#include <winevt.h>
#include <mutex>
#include <chrono>

using namespace std;

//this can also be done with a g++ compiler flag usually, which is what we do in the make file
#pragma comment(lib, "ws2_32.lib") //links the winsock2 library (for communication with subprocesses)
#pragma comment(lib, "wevtapi.lib") //links windows event api library (to not get interrupted by or restart upon sleep/logon events)

// to compile this by itself
// /g++ server.cpp -o server.exe -static -lws2_32 -lwevtapi

/*
    This is the main server process, generated by the GUI whenever patterns are applied.
    It first generates all currently implemented API subprocesses, then attempts to connect to them via sockets to relay device and pattern information (assuming the APIs are installed)
    Any subprocesses for APIs not installed on the computer simply close after failing to establish a connection.
    Once connected, this processes relays device pattern information to the subprocesses so they can turn the data into actual patterns on the rgb devices.
    This process should be terminated with the windows terminateprocess signal (which is called from the GUI when necessary), which will close the sockets so the subprocesses can terminate safely.

    The messages that get sent to the subprocesses have the following packet structure:

    -----------------------------------------
    DEVICE_ID R_VALUE G_VALUE B_VALUE A_VALUE
        ^         ^       ^       ^       ^
    2 bytes  3 bytes 3 bytes 3 bytes  3 bytes
    -----------------------------------------
*/

const int PORT = 50025; //the port for all communication between this process and subprocesses, this must be common among all the api clients
const int API_TIMEOUT_DURATION = 3; //the time (in seconds) that we wait for a subprocess API to connect

//all currently implemented API clients, update this whenever a new one is ready to go
std::vector<std::string> API_PATHS = { //note that these must be relative paths, because they go inside the temporary pyinstaller directory
    "./APIs/iCUESDK/corsairAPIclient.exe",
    "./APIs/RAZER/razerAPIclient.exe",
};
const int API_COUNT = API_PATHS.size();

mutex socket_mtx; //this is only used because asynchronous event handlers access the list of client sockets

SOCKET listeningSocket;
std::vector<SOCKET> clientSockets; //all sockets used by subprocesses

std::chrono::steady_clock::time_point lastHandledEvent; //this is used for when we listen for windows logon events to ignore all that come in after a certain time frame

//rainbow rgb values used in certain pattern implementations
std::map<int, tuple<int,int,int>> rainbow_keys = {{0, {255, 0, 0}},{1, {255, 255, 0}},{2, {0, 255, 0}},
                                                    {3, {0, 255, 255}},{4, {0, 0, 255}},{5, {255, 0, 255}},
                                                    {6, {255, 255, 255}}};

struct rgb {
    /*
    Struct that contains all information needed for a device's pattern to function properly. Note that each device type requested gets its own rgb struct.
    R, G, B, and A values correspond to the current value at the moment (these values are to be mutated)
    */

    //the following are not to be mutated
    int device_id; //corresponds to the index of the device type, see SUPPORTED DEVICES in monitor.py

    int r;
    int g;
    int b;
    int a;

    int speed; //0-2 inclusive, 0:slow 1:medium 2:fast
    char * pattern; //name of pattern, check monitor.py for all currently implemented patterns

    int count; //used for certain patterns that need colours to remain unchanged for a set amount of time

    //the following are not to be mutated and are set upon pattern creation
    int initial_r;
    int initial_g;
    int initial_b;

    int pulse; //used for pulse patterns to indicate increasing/decreasing, should be either 1 or -1
    int rainbow_index; //used for rainbowpulse to indicate which 
    char rainbow_changing_color; //used for rainbowcycle to indicate which of R, G, or B is changing

    void (* patternFunction)(struct rgb *); //pattern function to be called each time we update the colours, this mutates RBGA values
};

void staticPattern(struct rgb * rgb) {
    //static patterns do not need to change anything whatsoever, so we can simply return
    return;
}

void pulsePattern(struct rgb * rgb) {
    /*
    Pulse pattern for devices. Depending on the pulse attribute of rgb, we either R, G, and B to their initial values, or decrement to 0. 
    Upon reaching 0x000000 (black, equivalent of rgb off), we use the count attribute to hold the current pattern for a specified amount of time, to give the effect of breathing.
    */

    if (rgb->r == rgb->initial_r && rgb->g == rgb->initial_g && rgb->b == rgb->initial_b) { //we have reached our inital colour, now we can start decrementing
        rgb->r = max(0, rgb->initial_r - 1);
        rgb->g = max(0, rgb->initial_g - 1);
        rgb->b = max(0, rgb->initial_b - 1);
        rgb->pulse = -1;
        return;
    }

    if (rgb->r == 0 && rgb->g == 0 && rgb->b == 0) { //we have reached 0x000000
        if (rgb->count == 50) { //count has reached the end of its timer, we can now start incrementing back to the initial RGB values
            rgb->r = min(1, rgb->initial_r);
            rgb->g = min(1, rgb->initial_g);
            rgb->b = min(1, rgb->initial_b);
            rgb->pulse = 1;
            rgb->count = 0;
        } else {
            rgb->count += 1;
        }
        return;
    }

    //the following simply increments/decrements R, G, and B according to the initial values
    //note that we cannot decrement past 0 or increment past our initial values, so sometimes we will have to wait until the last value reaches its max/min until we swap the pulse attribute's value
    if (rgb->r >= rgb->initial_r) {
        rgb->r = rgb->initial_r;
    } else if (rgb->r <= 0) {
        rgb->r = 0;
    } else {
        rgb->r += rgb->pulse;
    }
    if (rgb->g >= rgb->initial_g) {
        rgb->g = rgb->initial_g;
    } else if (rgb->g <= 0) {
        rgb->g = 0;
    } else {
        rgb->g += rgb->pulse;
    }
    if (rgb->b >= rgb->initial_b) {
        rgb->b = rgb->initial_b;
     } else if (rgb->b <= 0) {
        rgb->b= 0;
     } else {
        rgb->b += rgb->pulse;
     }
}

void rainbowPulsePattern(struct rgb * rgb) {
    /*
    Rainbow pulse pattern. Calls pulse pattern first and uses the same logic, the only difference being that we change the colour to something else upon going dark.
    */
    pulsePattern(rgb);
    if (rgb->r == 0 && rgb->g == 0 && rgb->b == 0 && rgb->count == 50) {
        rgb->rainbow_index = (rgb->rainbow_index + 1) % 7;
        rgb->initial_r = get<0>(rainbow_keys[rgb->rainbow_index]);
        rgb->initial_g = get<1>(rainbow_keys[rgb->rainbow_index]);
        rgb->initial_b = get<2>(rainbow_keys[rgb->rainbow_index]);
    }
}

void rainbowCyclePattern(struct rgb * rgb) {
    /*
    Rainbow cycle pattern, or 'spectrum cycling.' Always keeps one of R, G, and B at 255, and another at 0, and increments/decrements the remaining value based on pulse
    and the rainbow_changing_color value.
    */
    if (rgb->r == 255 && rgb->pulse == 1 && rgb->rainbow_changing_color == 'g') {
        rgb->g += 1;
        if (rgb->g >= 255) {
            rgb->pulse = -1;
            rgb->rainbow_changing_color = 'r';
        }
        return;
    }
    if (rgb->g == 255 && rgb->pulse == -1 && rgb->rainbow_changing_color == 'r') {
        rgb->r -= 1;
        if (rgb->r == 0) {
            rgb->pulse = 1;
            rgb->rainbow_changing_color = 'b';
        }
        return;
    }
    if (rgb->g == 255 && rgb->pulse == 1 && rgb->rainbow_changing_color == 'b') {
        rgb->b += 1;
        if (rgb->b == 255) {
            rgb->pulse = -1;
            rgb->rainbow_changing_color = 'g';
        }
        return;
    }
    if (rgb->b == 255 && rgb->pulse == -1 && rgb->rainbow_changing_color == 'g') {
        rgb->g -= 1;
        if (rgb->g == 0) {
            rgb->pulse = 1;
            rgb->rainbow_changing_color = 'r';
        }
        return;
    }
    if (rgb->b == 255 && rgb->pulse == 1 && rgb->rainbow_changing_color == 'r') {
        rgb->r += 1;
        if (rgb->r == 255) {
            rgb->pulse = -1;
            rgb->rainbow_changing_color = 'b';
        }
        return;
    }
    if (rgb->r == 255 && rgb->pulse == -1 && rgb->rainbow_changing_color == 'b') {
        rgb->b -= 1;
        if (rgb->b == 0) {
            rgb->pulse = 1;
            rgb->rainbow_changing_color = 'g';
        }
        return;
    }
}

void randomStrobePattern(struct rgb * rgb) {
    /*
    Random strobe pattern, switches to a randomly generated colour (from the predefined options above). Uses count as to not update incredibly frequently.
    */
    if (rgb->count == 0) {
        int color = rand() % 7;
        rgb->r = get<0>(rainbow_keys[color]);
        rgb->g = get<1>(rainbow_keys[color]);
        rgb->b = get<2>(rainbow_keys[color]);
    }
    rgb->count = (rgb->count + 1) % 10;
}

void firePattern(struct rgb * rgb) {
    /*
    Cool fire pattern that blazes similarly to a fireplace. Utilizes the pulse attribute to solely to change the g value, while r and b remain unchanged.
    */
    
    if (rgb->g >= 55) {
        rgb->pulse = -1;
        rgb->g = 54;
        return;
    }
    if (rgb->g == 0) {
        if (rgb->count == 30) {
            rgb->count = 0;
            rgb->g = 1;
            rgb-> pulse = 1;
            return;
        } else {
            rgb->count += 1;
            return;
        }
    }
    rgb->g += rgb->pulse;
}

SOCKET create_socket() {
    /*
    Creates and returns a socket to be used as the main server's listening socket for clients.
    Similar to the official winsock server example: https://learn.microsoft.com/en-us/windows/win32/winsock/complete-server-code
    */

    WSADATA wsaData;
    SOCKET listeningSocket;
    sockaddr_in serverAddr;

    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        exit(1);
    }

    //create the socket
    listeningSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (listeningSocket == INVALID_SOCKET) {
        WSACleanup();
        exit(1);
    }

    //specify TCP and localhost, and use the application's port
    const char* address = "127.0.0.1";
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT);
    serverAddr.sin_addr.s_addr = inet_addr(address);

    //bind the socket to port
    if (bind(listeningSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        closesocket(listeningSocket);
        WSACleanup();
        exit(1);
    }

    //check for listening errors before we start connecting subprocesses
    if (listen(listeningSocket, SOMAXCONN) == SOCKET_ERROR) {
        closesocket(listeningSocket);
        WSACleanup();
        exit(1);
    }
    return listeningSocket;
}

void create_client_subprocesses() {
    /*
    Generates the subprocesses based on the api paths listed above. Does not connect any of them to the server process.
    */
    for (size_t i = 0; i < API_COUNT; ++i) {

        //for this we uses Windows' CreateProcess: https://learn.microsoft.com/en-us/windows/win32/procthread/creating-processes
        //the following code for generating our subprocesses is basically the same, except we need not wait on them or close them

        /*
        we don't need to save the startup and process information, so we can reuse variables here
        though we might want to save these for later, just so we can call:

            WaitForSingleObject( pi.hProcess, INFINITE );
            CloseHandle( pi.hProcess );
            CloseHandle( pi.hThread );

        on each of them when the server has to close. This likely is not necessary however, because of the handling in the subprocesses; whenever the
        socket closes or times out, the subprocesses closes itself (and the patterns stop displaying).
        */

        STARTUPINFOA si;
        PROCESS_INFORMATION pi;

        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        ZeroMemory(&pi, sizeof(pi));

        //we are calling our subprocesses from the command line using relative paths
        std::string cmdLine = API_PATHS[i];

        if (!CreateProcessA(
                NULL,               // No module name (use command line)
                cmdLine.data(),     // Command line, NOTE we are using .data() to obtain a mutable copy
                NULL,               // Process handle not inheritable
                NULL,               // Thread handle not inheritable
                FALSE,              // Set handle inheritance to FALSE
                0,                  // No creation flags
                NULL,               // Use parent's environment block
                NULL,               // Use parent's starting directory 
                &si,                // Pointer to STARTUPINFO structure
                &pi)                // Pointer to PROCESS_INFORMATION structure
            ) {
            continue; //keep creating the rest if one of them creates an error
        }
    }
}

void connect_subprocesses(SOCKET listeningSocket, std::vector<SOCKET> * clientSockets) {
    /*
    Connects API_COUNT amount of subprocesses to the main server's listening socket and accepts their connections.
    Currently does not use API_TIMEOUT_DURATION, still using an experimentive 3 second timeout to see if it is more efficient.
    Returns after all subprocesses connect, or if no API subprocess responds within the timeout duration.
    */
   
    int clientsAccepted = 0;

    while (clientsAccepted < API_COUNT) {
        //here we use fd_set as a buffer for our incoming connections
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(listeningSocket, &readfds);

        timeval timeout = {};
        timeout.tv_sec = API_TIMEOUT_DURATION;
        timeout.tv_usec = 0;

        int result = select(0, &readfds, NULL, NULL, &timeout);
        if (result > 0 && FD_ISSET(listeningSocket, &readfds)) {
            SOCKET clientSock = accept(listeningSocket, NULL, NULL); //accept the incoming connection
            if (clientSock != INVALID_SOCKET) {
                //API subprocess has connected, so we add it to our array
                clientsAccepted++;
                clientSockets->push_back(clientSock);
            } 
        } else if (result == 0) { //break if it can't find another connection
            break;
        } else {
            // use WSAGetLastError() for error handling here
            break;
        }
    }
}

DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, PVOID pContext, EVT_HANDLE hEvent) {
    /*
    Callback function for when the subscription event handler detects a logon event.
    Mostly the same as the official winapi event handler: https://learn.microsoft.com/en-us/windows/win32/wes/subscribing-to-events
    */
    if (action == EvtSubscribeActionDeliver) {
        DWORD bufferSize = 0;
        DWORD bufferUsed = 0;
        DWORD propertyCount = 0;
        LPWSTR renderedContent = NULL;

        auto now = std::chrono::steady_clock::now();
        if (std::chrono::duration_cast<std::chrono::seconds>(now - lastHandledEvent).count() < 5) //here we check if other events also came in during the last 5 seconds (we then ignore this event)
            return ERROR_SUCCESS;

        //renders the event as XML to read its values and buffers
        if (!EvtRender(NULL, hEvent, EvtRenderEventXml, bufferSize, renderedContent, &bufferUsed, &propertyCount)) {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                bufferSize = bufferUsed;
                renderedContent = (LPWSTR)malloc(bufferSize);
                if (renderedContent) {
                    if (EvtRender(NULL, hEvent, EvtRenderEventXml, bufferSize, renderedContent, &bufferUsed, &propertyCount)) {
                        socket_mtx.lock();  
                        wprintf(L"Event: %s\n", renderedContent);
                        for (SOCKET clientSockclose : clientSockets) { //close each subprocess
                            closesocket(clientSockclose);
                        }
                        //finally close the host socket and cleanup
                        closesocket(listeningSocket);
                        WSACleanup();

                        //refresh the client sockets, recreate all subprocesses and connect them
                        clientSockets.clear();
                        create_client_subprocesses();
                        listeningSocket = create_socket();
                        connect_subprocesses(listeningSocket, &clientSockets);
                        socket_mtx.unlock();  
                    }
                    free(renderedContent);
                    lastHandledEvent = now;
                }
            }
        }
    }
    return ERROR_SUCCESS;
}

int main(int argc, char** argv) {

    //this process takes arguments that are a multiple of seven, with the structure seen in the examples below
    if ((argc - 1) % 7 != 0) { //we shouldn't get here since this process is only called from the GUI, but...
        //e.x. usage: './server.exe device r g b a speed pattern'
        //e.x. usage: './server.exe device1 r1 g1 b1 a1 speed1 pattern1 device2 r2 g2 b2 a2 speed2 pattern2'
        //device is a value device_id (index of device within SUPPORTED_DEVICES, see monitor.py), rgba are values 0-255, speed is a value 0-2, pattern is a valid string (see monitor.py)
        return 1;
    }

    socket_mtx.lock();  
    //generate subprocesses for each device brand API here
    create_client_subprocesses();

    //host socket creation here
    //once again, we are using Windows' socket implementation Winsock2: https://learn.microsoft.com/en-us/windows/win32/winsock/complete-server-code
    //the initial setup is nearly identical here, then differs when we start listening for each connection

    SOCKET listeningSocket = create_socket();

    //we store each client's socket in an array so we can send device pattern data through to each of them easily
    std::vector<SOCKET> clientSockets;

    connect_subprocesses(listeningSocket, &clientSockets);

    socket_mtx.unlock();  

    //this event subscriber handles log on events from the user (note: it will handle much more than one event per logon, so the timeout above is needed)
    EVT_HANDLE hSubscription = NULL;
    const wchar_t* channel = L"Security";
    const wchar_t* query = L"Event[System[EventID=4624] and EventData[Data[@Name='LogonType']='2' or Data[@Name='LogonType']='7']]";
    hSubscription = EvtSubscribe(
        NULL, NULL, channel, query, NULL, NULL,
        SubscriptionCallback, EvtSubscribeToFutureEvents
    );

    //we have this many devices with patterns
    int device_count = (argc - 1) / 7;

    //low and medium speed patterns are updated every 2 and 3 iterations respectively, high speed patterns are updated every iteration
    int medium_speed_count = 0;
    int low_speed_count = 0;

    std::vector<struct rgb> device_patterns = {};
    int arg_index = 1;
    //here we construct our list of patterns for devices based on the arguments given to the server process
    for (int index = 0; index < device_count; index++) {
        struct rgb device_pattern;
        //initialize the device patterns with the input to the program
        device_pattern.device_id = atoi(argv[arg_index]); //device_id is an int denoting the device type identifier (e.x. keyboard = 1, mouse = 2)
        device_pattern.r = atoi(argv[arg_index + 1]);
        device_pattern.g = atoi(argv[arg_index + 2]);
        device_pattern.b = atoi(argv[arg_index + 3]);
        device_pattern.a = atoi(argv[arg_index + 4]);
        device_pattern.speed = atoi(argv[arg_index + 5]);
        device_pattern.pattern = argv[arg_index + 6];
        arg_index += 7;

        device_pattern.initial_r = device_pattern.r;
        device_pattern.initial_g = device_pattern.g;
        device_pattern.initial_b = device_pattern.b;

        //these are always initialized to the same values before a pattern is added
        device_pattern.count = 0;
        device_pattern.pulse = 1;
        device_pattern.rainbow_index = 0;

        //now we must add the correct pattern function attribute to the device pattern
        //certain patterns change our initial values

        //TODO: change this something better? switch case isn't a thing here
        if (strcmp(device_pattern.pattern, "static") == 0) {
            device_pattern.patternFunction = (&staticPattern);
        } else if (strcmp(device_pattern.pattern, "randomstrobe") == 0) {
            device_pattern.patternFunction = (&randomStrobePattern);
        } else if (strcmp(device_pattern.pattern, "pulse") == 0) {
            device_pattern.patternFunction = (&pulsePattern);
        } else if (strcmp(device_pattern.pattern, "rainbowpulse") == 0) {
            device_pattern.patternFunction = ( &rainbowPulsePattern);
        } else if (strcmp(device_pattern.pattern, "rainbowcycle") == 0) {
            device_pattern.patternFunction = (&rainbowCyclePattern);
            device_pattern.r = 255;
            device_pattern.g = 0;
            device_pattern.b = 0;
            device_pattern.rainbow_changing_color = 'g';
            device_pattern.pulse = 1;
        } else if (strcmp(device_pattern.pattern, "fire") == 0) {
            device_pattern.patternFunction = (&firePattern);
            device_pattern.r = 255;
            device_pattern.g = 0;
            device_pattern.b = 0;
            device_pattern.pulse = 1;
            device_pattern.count = 0;
            device_pattern.initial_g = rand() % 100; //we use this as the max g value
        } else {
            device_pattern.patternFunction = (&staticPattern);
        }    

        //finally add the newly created device pattern to the rest
        device_patterns.push_back(device_pattern);
    }

    while (true) { //the main loop of our server now begins, where we update device pattern data each loop iteration and send it to the subprocesses for handling

        try {

            for (int index = 0; index < device_patterns.size(); index++) {

                //check if the pattern should be handled this loop based on its speed
                if (device_patterns[index].speed == 2 || 
                    (device_patterns[index].speed == 1 && medium_speed_count == 1) ||
                    (device_patterns[index].speed == 0 && low_speed_count == 2)) {
                
                    //use the pattern and mutate the rgb values
                    device_patterns[index].patternFunction(&device_patterns[index]);

                    //here we have our message that we be send to each API client
                    char message[15];
                    char buf[4];
                    memset(buf, '\0', 4);
                    memset(message, '\0', 15);
                    int amount_copied;

                    /* our message has the following packet structure:

                    -----------------------------------------
                    DEVICE_ID R_VALUE G_VALUE B_VALUE A_VALUE
                        ^         ^       ^       ^       ^
                    2 bytes  3 bytes 3 bytes 3 bytes  3 bytes
                    -----------------------------------------

                    */

                    //we must carefully construct the message to be sent, including null-termination

                    //DEVICE_ID
                    sprintf(buf, "%d", device_patterns[index].device_id);
                    amount_copied = strlen(buf);
                    strncpy(message, buf, amount_copied);
                    strncpy(message + amount_copied, "   ", 2 - amount_copied); //2 spaces
                    message[2] = '\0';

                    //R_VALUE
                    sprintf(buf, "%d", device_patterns[index].r);
                    amount_copied = strlen(buf);
                    strncpy(message + 2, buf, amount_copied);
                    strncpy(message + 2 + amount_copied, "   ", 3 - amount_copied); //3 spaces
                    message[5] = '\0';

                    //G_VALUE
                    sprintf(buf, "%d", device_patterns[index].g);
                    amount_copied = strlen(buf);
                    strncpy(message + 5, buf, amount_copied);
                    strncpy(message + 5 + amount_copied, "   ", 3 - amount_copied); //3 spaces
                    message[8] = '\0';
                    
                    //B_VALUE
                    sprintf(buf, "%d", device_patterns[index].b);
                    amount_copied = strlen(buf);
                    strncpy(message + 8, buf, amount_copied);
                    strncpy(message + 8 + amount_copied, "   ", 3 - amount_copied); //3 spaces
                    message[11] = '\0';

                    //A_VALUE
                    sprintf(buf, "%d", device_patterns[index].a);
                    amount_copied = strlen(buf);
                    strncpy(message + 11, buf, amount_copied);
                    strncpy(message + 11 + amount_copied, "   ", 3 - amount_copied); //3 spaces

                    message[14] = '\0'; //null terminate the message

                    socket_mtx.lock(); //we must ensure concurrency when mutating the client sockets

                    //now we send the message to each subprocess that has been connected
                    for (SOCKET clientSock : clientSockets) {
                        int sendResult = send(clientSock, message, strlen(message), 0);
                        if (sendResult == SOCKET_ERROR) { //if we encounter an error with sending the message, CLOSE AND RECREATE ALL SUBPROCESSES AND SOCKETS
                            for (SOCKET clientSockclose : clientSockets) { //close each subprocess (closing the socket ends up closing the subprocesses because of how its handled client side)
                                closesocket(clientSockclose);
                            }

                            //finally close the host socket and cleanup
                            closesocket(listeningSocket);
                            WSACleanup();

                            //refresh the client sockets, recreate all subprocesses and connect them
                            clientSockets.clear();
                            create_client_subprocesses();
                            listeningSocket = create_socket();
                            connect_subprocesses(listeningSocket, &clientSockets);
                            break;
                        }
                     }  
                    socket_mtx.unlock();  
                 }
            }

            //increment the counters for handling pattern speeds
            medium_speed_count =  (medium_speed_count + 1) % 2;
            low_speed_count = (low_speed_count + 1) % 3;

            Sleep(50); //sleep here is essential for not only maintaining consistency among CPUs, but also not overloading certain APIs (like RAZER's restful server)
        }
            catch (...) { //this will catch terminateprocess signals from the GUI
                for (SOCKET clientSock : clientSockets) { //close each subprocess
                    closesocket(clientSock);
                }
                //finally close the host socket and cleanup
                closesocket(listeningSocket);
                WSACleanup();
                if (hSubscription != NULL)  { //close the event subscriber
                    EvtClose(hSubscription);
                }
                break;
            }
    }

    /* though not necessary because of how the APIs close themselves properly after receiving the socket closing signal,
    we could store windows process information for the subprocesses until we close them here.

    //waits until child process exits
    WaitForSingleObject(pi.hProcess, INFINITE);

    //closes the process and thread handle
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    */
    if (hSubscription != NULL)  { //close the event subscriber
        EvtClose(hSubscription);
    }
    return 0;
}